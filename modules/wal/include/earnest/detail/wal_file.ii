#ifndef EARNEST_DETAIL_WAL_FILE_INL_H
#define EARNEST_DETAIL_WAL_FILE_INL_H

#include <functional>
#include <unordered_map>

#include <earnest/detail/completion_barrier.h>
#include <earnest/detail/positional_stream_adapter.h>
#include <earnest/detail/completion_wrapper.h>
#include <earnest/wal_error.h>
#include <earnest/xdr.h>

#include <asio/associated_allocator.hpp>
#include <asio/associated_executor.hpp>
#include <asio/bind_allocator.hpp>
#include <asio/bind_executor.hpp>
#include <asio/executor_work_guard.hpp>
#include <asio/buffered_read_stream.hpp>

namespace earnest::detail {


template<typename Executor>
inline wal_file_entry<Executor>::wal_file_entry(const executor_type& ex)
: file(ex)
{}

template<typename Executor>
inline auto wal_file_entry<Executor>::header_reader_() {
  using namespace std::string_literals;

  return ::earnest::xdr_reader<>()
      & xdr_constant("\013\013earnest.wal"s).as(xdr_raw_bytes<13>)
      & xdr_uint32(version)
      & xdr_processor(
          [this]() -> std::error_code {
            if (version > max_version)
              return make_error_code(wal_errc::bad_version);
            return {};
          })
      & xdr_uint64(sequence);
}

template<typename Executor>
inline auto wal_file_entry<Executor>::header_writer_() const {
  using namespace std::string_literals;

  return ::earnest::xdr_writer<>()
      & xdr_constant("\013\013earnest.wal"s).as(xdr_raw_bytes<13>)
      & xdr_processor(
          [this]() -> std::error_code {
            if (version > max_version)
              return make_error_code(wal_errc::bad_version);
            return {};
          })
      & xdr_uint32(version)
      & xdr_uint64(sequence);
}

template<typename Executor>
template<typename CompletionToken>
inline auto wal_file_entry<Executor>::async_open(const dir& d, const std::filesystem::path& name, CompletionToken&& token) {
  using pos_stream = positional_stream_adapter<fd<executor_type>&>; // XXX replace with buffered positional stream

  return asio::async_initiate<CompletionToken, void(std::error_code)>(
      [](auto completion_handler, const dir& d, const std::filesystem::path& name, std::unique_ptr<pos_stream> s, wal_file_entry& wf) {
        auto& stream = *s;
        if (wf.file.is_open()) throw std::logic_error("wal is already open");
        if (name.has_parent_path()) throw std::runtime_error("wal file must be a filename");

        {
          std::error_code ec;
          wf.file.open(d, name, fd<executor_type>::READ_WRITE, ec);
          if (ec) {
            auto ex = asio::get_associated_executor(completion_handler, wf.get_executor());
            auto alloc = asio::get_associated_allocator(completion_handler);
            ex.post(
                completion_wrapper<void()>(
                    std::move(completion_handler),
                    [ec](auto h) { std::invoke(h, ec); }),
                alloc);
            return;
          }
          wf.name = name;
        }

        async_read(
            stream, wf.header_reader_(),
            completion_wrapper<void(std::error_code)>(
                std::move(completion_handler),
                [stream_ptr=std::move(s)](auto& h, std::error_code ec) mutable {
                  stream_ptr.reset();
                  std::invoke(h, ec);
                }));
      },
      token, d, name, std::make_unique<pos_stream>(file), *this);
}


template<typename Executor, typename Alloc>
wal_file<Executor, Alloc>::wal_file(const executor_type& ex, allocator_type alloc)
: strand_(ex),
  files_(alloc),
  pending_writes_(std::move(alloc))
{}

template<typename Executor, typename Alloc>
template<typename CompletionToken>
auto wal_file<Executor, Alloc>::async_open(const std::filesystem::path& dirname, CompletionToken&& token)
-> typename asio::async_result<std::decay_t<CompletionToken>, void(std::error_code)>::return_type {
  if (d_.is_open()) throw std::runtime_error("wal is already open");
  d_.open(dirname, dir::READ_WRITE);

  asio::async_completion<CompletionToken, void(std::error_code)> init(token);
  auto callback =
      [ alloc=asio::get_associated_allocator(init.completion_handler, get_allocator()),
        guard=asio::make_work_guard(asio::get_associated_executor(init.completion_handler, get_executor())),
        impl=init.completion_handler
      ](std::error_code ec) {
        guard.get_executor().dispatch(
            [impl, ec]() {
              std::invoke(impl, ec);
            },
            alloc);
        guard.reset();
      };

  async_populate_wal_files_(std::move(callback));

  return init.result.get();
}

template<typename Executor, typename Alloc>
auto wal_file<Executor, Alloc>::get_allocator() const -> allocator_type {
  return pending_writes_.get_allocator();
}

template<typename Executor, typename Alloc>
auto wal_file<Executor, Alloc>::get_executor() const -> executor_type {
  return strand_.get_inner_executor();
}

template<typename Executor, typename Alloc>
template<typename Callback>
void wal_file<Executor, Alloc>::async_populate_wal_files_(Callback&& callback) {
  auto barrier = detail::make_completion_barrier(
      [ sp=this->shared_from_this(),
        callback=std::forward<Callback>(callback)
      ](std::error_code ec) mutable {
        if (ec) {
          std::invoke(std::move(callback), std::move(ec));
        } else if (sp->files_.empty()) {
          std::invoke(std::move(callback), std::make_error_code(std::errc::no_such_file_or_directory));
        } else {
          sp->async_process_wal_files_(std::move(callback));
        }
      },
      strand_);

  // Filter down to only the WAL files.
  for (const dir::entry& dir_entry : d_) {
    if (dir_entry.is_regular_file() && dir_entry.path().extension() == ".wal") {
      files_.emplace_back(get_executor());
      files_.back().async_open(d_, dir_entry, asio::bind_allocator(get_allocator(), ++barrier));
    }
  }

  // Allow the barrier to proceed.
  barrier(std::error_code());
}

template<typename Executor, typename Alloc>
template<typename Callback>
void wal_file<Executor, Alloc>::async_process_wal_files_(Callback&& callback) {
  // XXX implement
  std::invoke(std::forward<Callback>(callback), std::make_error_code(std::errc::not_supported));
}


template<typename Executor, typename Alloc>
inline wal_file<Executor, Alloc>::tx::tx(wal_file& wf)
: wf_(wf.shared_from_this()),
  pending_writes_(wf.get_allocator()),
  read_ranges_(wf.get_allocator())
{}


} /* namespace earnest::detail */

#endif /* EARNEST_DETAIL_WAL_FILE_INL_H */
