#ifndef EARNEST_SEQUENCE_H
#define EARNEST_SEQUENCE_H

#include <cstdint>
#include <utility>
#include <earnest/txfile.h>
#include <earnest/fd.h>

namespace earnest {


/**
 * \brief A transactional sequence.
 * \details
 * A sequence allows for sequentially allocating unique numbers.
 *
 * The sequence operates outside transaction context, thus guaranteeing
 * uniqueness of numbers even if called concurrently from multiple transactions.
 */
class earnest_export_ sequence {
  public:
  ///\brief File magic.
  static constexpr uint64_t MAGIC = 0x0290'4b5c'15c8'94d6ULL;
  ///\brief Size in bytes that the sequence occupies in the file.
  static constexpr fd::size_type SIZE = 16u;

  ///\brief The type of integer generated by the sequence.
  using type = std::uint64_t;

  static_assert(sizeof(MAGIC) + sizeof(type) == SIZE);

  sequence() = default;

  /**
   * \brief Create a sequence object from a file.
   * \details The sequence will modify the file content when changed.
   * \param[in,out] f The file upon which the sequence acts.
   * \param[in] off Offset at which the sequence exists in the file.
   * \param[in] cache_size When the file is updated, batch this number of allocations.
   */
  sequence(txfile& f, fd::offset_type off, type cache_size = 1u);

  sequence(const sequence&) = delete;
  sequence& operator=(const sequence&) = delete;

  ///\brief Move constructor.
  ///\param[in] other The value to move from.
  ///\note Not thread safe.
  sequence(sequence&& other) noexcept
  : txfile_impl_(std::exchange(other.txfile_impl_, std::weak_ptr<txfile::impl_>())),
    off_(other.off_),
    cache_avail_(std::exchange(other.cache_avail_, 0u)),
    cache_val_(other.cache_val_),
    cache_size_(std::exchange(other.cache_size_, 0u))
  {}

  ///\brief Swap operation.
  ///\param[in] x,y The sequences to be swapped.
  ///\note Not thread safe.
  friend void swap(sequence& x, sequence& y) noexcept {
    using std::swap;

    swap(x.txfile_impl_, y.txfile_impl_);
    swap(x.off_, y.off_);
    swap(x.cache_avail_, y.cache_avail_);
    swap(x.cache_val_, y.cache_val_);
    swap(x.cache_size_, y.cache_size_);
  }

  ///\brief Move assignment.
  ///\note Not thread safe.
  inline auto operator=(sequence&& other) noexcept -> sequence& {
    txfile_impl_ = std::exchange(other.txfile_impl_, std::weak_ptr<txfile::impl_>());
    off_ = other.off_;
    cache_avail_ = std::exchange(other.cache_avail_, 0u);
    cache_val_ = other.cache_val_;
    cache_size_ = std::exchange(other.cache_size_, 0u);
    return *this;
  }

  /**
   * \brief Initalize a new sequence.
   * \details
   * Overwrites \p SIZE bytes at \p off initializing a new sequence.
   * The sequence will be initialized with \p init as its first number to return.
   *
   * \note The sequence is unusable until the transaction has been committed.
   * \param[in,out] tx A writeable transaction in the file.
   * \param[in] off The offset at which the sequence will exist.
   * \param[in] init The initial value of the sequence.
   */
  static void init(txfile::transaction& tx, fd::offset_type off, type init = 0u);

  /**
   * \brief Allocate a number from the sequence.
   * \details
   * Allocates the next sequence number and increments the internal state.
   * This function will update the stored state if the cached numbers run out.
   * \return Unique sequence.
   */
  auto operator()() -> type;

  private:
  std::weak_ptr<txfile::impl_> txfile_impl_;
  fd::offset_type off_;
  type cache_avail_ = 0u, cache_val_, cache_size_;
  std::mutex mtx_;
};


} /* namespace earnest */

#endif /* EARNEST_SEQUENCE_H */
